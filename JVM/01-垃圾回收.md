# 01-垃圾回收

###  如何判断对象已死？

* 引用计数算法

  给对象添加一个引用计数器，有一个对象引用它时计数器就 +1，当这个引用失效就 -1。当计数器为 0 时，就可以回收了。不太好解决循环引用的问题

* 可达性分析算法

  当一个对象到 GC Roots 没有任何引用链相连接，则被判定为可以回收的对象


### GC Roots 对象

* 虚拟机栈 (栈帧中的局部变量表) 中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中 Native 方法引用的对象

### 常见垃圾收集算法

||描述|备注|
|-|-|-|
|标记-清除|首先标记所有需要回收的对象，标记完成后统一回收所有被标记的对象|标记和清除俩过程的效率不是太高；清除后产生大量不连续的内存碎片，分配较大对象可能出现找不到足够连续内存而再次触发垃圾回收。适合老年代。|
|复制|将内存分为两块，每次只用一块，当内存用完就将活着的对象移到另一块上，再把已使用的内存空间全部清除|内存缩小了一半；对象存活率较高时需要进行较多的复制操作，效率将会降低。适合新生代。|
|标记-整理|首先标记所有需要回收的对象，然后把存活的对象向一端移动，然后清理掉端边界以外的内存|适合老年代|
|分代收集|将内存划为多块，如新生代和老年代，在不同的区域使用不同的收集算法|新生代对象死亡多存活少，适合“复制”算法；老年代对象存活率高，“标记-清除”和“标记-整理”算法更合适|