# 00-JVM 内存模型与结构

### 内存模型

在计算机中，CPU 和存储器之间交互频繁，但是由于 CPU 的速度很快而存储器的速度过慢，就设计了一系列的高速缓存来解决这个效率一致性问题，CPU 读取数据会从一级缓存、二级缓存、内存这样的顺序来查找，但多核 CPU 有自己的高速缓存又共享一个主内存，这带来了一个新问题，就是缓存一致性。为解决这个问题，又引入了内存屏障 (Memory Barrier)的概念：在写操作后插入一个写屏障指令，读操作前插入一个读屏障指令，保证写入后其他 CPU 能拿到最新的值（不同硬件的实现方式不大一样）。

Java 屏蔽了各种硬件和操作系统的差异，有自己的内存模型， 即 Java 内存模型 (JMM，Java Memory Model)，定义将变量存储到内存和从内存中取出变量的底层细节。在 Java 内存模型中，分为了主内存 (Main Memory)和工作内存 (Work Memory)。每个线程拥有自己的工作内存，不共享，但它们共享主内存。实例字段、静态字段、构成数组对象的元素存在主内存中，会被共享；而局部变量、方法参数在工作内存中，不会被共享，因为这是线程私有的，不会存在竞争问题。线程的工作内存保存了被使用到的变量的主内存副本拷贝，对变量的读写必须在工作内存中进行。当然，这也会有缓存一致性问题，例如多线程同时去读写一个变量的情况下极易发生。类似内存屏障的解法在 Java 中通过 volatile 关键字来实现，被它修饰的变量修改后能立即同步到主内存，而读取变量时会强制从主内存刷新。(使用 volatile 时一定要注意原子性的问题，否则还是会有缓存不一致的问题)

### 内存结构

1. #### PC (program counter) 寄存器，或程序计数器

   可看做是当前线程所执行的字节码的行号指示器，每个线程都有各自的 PC 寄存器，线程切换后才能恢复到正确的执行位置。

2. #### Java 虚拟机栈 (Java Virtual Machine Stack)

   每个线程有私有的 Java 虚拟机栈，生命周期和线程相同。执行每个方法都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，方法的调用和执行完成对应了一个栈帧的入栈到出站过程。
   
   * ##### 局部变量表
   
     保存参数和局部变量
   
   * ##### 操作数栈
   
     保存计算过程的中间结果，同时也是计算过程中变量临时存放的空间
   
   * #####  动态链接
   
     一个方法若用调用其他方法或者访问成员变量需要通过符号引用的方式，动态链接的作用就是将符号引用表示的方法转换为对实际方法的直接引用
   
3. #### 本地方法栈 (Native Method Stack)

   类似 Java 虚拟机栈，为 Native 方法服务。

4. #### Java 堆 (Java Heap)

   供各个线程共享的运行时内存区域，也是供类实例和数组对象分配内存的区域。

5. #### 方法区 (Method Area)

   供各个线程共享的运行时内存区域，存储已被虚拟机加载类信息、常量、静态变量、即时编译器编译后的代码等数据，别名 Non-Heap。

6. #### 运行时常量池 (Runtime Constant Pool)
   
   存放编译期生成的各种字面量和符号引用
   
7. #### 直接内存 (Direct Memory)

   不是 Java 虚拟机规范所规定的内存区域，例如可通过 NIO 进行操作